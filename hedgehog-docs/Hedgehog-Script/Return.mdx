import { MathJax, MathJaxContext } from 'better-react-mathjax'


# Return Statements

The `return` statement is something you may be very familiar with, and it's relatively simple! It ends function execution and specifies a value to be returned to the function caller.

Here is a very simple, brief example:

```js
function getCircleArea(radius) {
    if (radius > 0) {
        return Math.PI*radius*radius;
    }
    return 0;
}
print(getCircleArea(5)); //expected output: 78.54
print(getCircleArea(-1)); //expected output: 0
```
The syntax of a `return` statement is simply: `return [expression];`. If [expression] is omitted, `undefined` is returned instead.

Automatic Semicolon Insertion: this may be a new concept, but it affects the `return` statement. Basically, since no line terminator (newline for example) is allowed between `return` and the expression, it will transform the text through ASI to force a semicolon after return. But this means then that return has no expression hence returns undefined, and another problem is, the expression after the line terminator will not be reachable since return ends function execution and the expression becomes separated by a semicolon:

```js
return
a+b; // this is technically wrong and is transform by ASI - Automatic Semicolon Insertion into...

return;
a+b; //now return gives undefined and a larger problem is there is unreachable code, namely, 'a+b;'

//Overall make sure that there is no line termination between return keywords and their expressions.
```

Another way to avoid this problem is by adding parentheses around the expression when there is a line terminator, if one needs to have it:

```js
return (
    a+b
);
```

Aside from the default way of using `return`, one other way is to intentionally interrupt a function:

```js
function counter() {
    for (let count = 1; ; count++) { //this is an infinite loop which can and will lead to problems!
        print(`${count}A`); // lets say we want to go until 7...
        if (count === 7) {
            return;
        }
        print(`${count}B`);
    }
    print(`${count}C`);
}

//the output will be: 1A 1B 2A 2B 3A 3B 4A 4B 5A 5B 6A 6B 7A
```

Let's unwrap this: First let's discuss the ``${count}A`` expression. As one may imagine, backticks (` `) are used to wrap the computated expression, ${} evaluates the variable at that time, and the A after just attaches an 'A' with no space before to the evaluation of ${count}. These computated expresssions can be quite useful in complex scenarios. Next, the important thing is to understand the brackets and what it means for the structure of the function - notice there is a print statement with a 'C' being attached to count's value. This is outside the for-loop, so it should execute it once the for loop is finished right? Right technically, however, the loop is first infinite so it will never be reached without a `break;` secondhand, there is a valid `return` condition which completely stops the execution of the whole function. Thus, it's technically unreachable code. Now, consider the print statement ending with 'B'. It is outside the `if-condition` but in the `for-loop`. This means it will be executed every time the if condition is fully executed (without interruption) or fails. The if condition is based on if `count===7`. So it will fail for 1, 2, 3, 4, 5, and 6. So the print 'B' statement will run for each of those count values. However, on the 7th, the if condition is satisfied hence `return;` is called, completely ending the function execution. Lastly, the print 'A' statement is **before** the if condition so it will execute every single time, until the for loop ends or in this case, `return;` is called. So it will be called for 1, 2, 3, 4, 5, 6, and even 7 because the check for `count===7` happens after the print statement. This explains the output.

Another useful feature of `return` statements is not to return a value, but rather a function:

```js
function magic() {
    return function calc(x) { return x*50; };
}

const result = magic();
print(result(100)); //Expected result is 100*50 = 5000. This is because result is set to be the magic function - which returns a function that has a parameter, x, and returns x*50. Hence result is actually a function! You could say `function result(x) { return x* 50; }` is the value of 'result'. Hence, when you call it with a parameter, it's basically like having `function result(x) { return x*50; }` being available and result(100) simply, well, calls the result function with parameter 100, returning 100*50.
```
This is similar to a concept called closure in JavaScript.

Overall, this is a review of `return` statements, and one needs to acknowledge that `return` completely ends function execution when called. If there's no expression to return, it returns `undefined`. Other than for it's normal use, `return` can be used for interrupting a function and returning functions among other techniques.