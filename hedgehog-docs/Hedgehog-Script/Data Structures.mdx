import { MathJax, MathJaxContext } from 'better-react-mathjax'


# Data Structures

Data structures in JavaScript (or any programming language) is a format to organize, manage and store data in a way that allows efficient access and modification. Moreover, data structures are a collection of data values, the relationships among them if any, and the functions and operations that can be applied to said data. This may sound possibly complicated or abstract initially, however, there are many data structures you're likely familiar with. We'll start with native JavaScript ones and then give some examples of constructed data types. Data structures are very crucial for projects or even simple scripts as they handle data - one of the, if not the most, important things in programming.

First let's discuss a built-in data structure that we should all be familar with: Arrays. Arrays are covered in the 'Arrays' section in 'Built-in Objects'. And as this chapter is simply showing data structures and explaining a bit about them, we're not going to get to all the details of an Array object. Just be aware that there are functions for storing, managing and manipulating data in an Array. Second, there's `objects` in JavaScript. Another thing one may be familiar with, these are actually data structures in themselves - they hold data via properties, and can manage or modify it via methods in the object. Specifically objects in JavaScript are hash tables. It can also be called a map or dictionary, because it holds key-value pairs.

Next, let's consider `stacks`, an important data structure. These store information like a list. They work under a LIFO pattern (last in, first out i.e. when you put elements in, to return or `pop()` one, you need to pop the most recent one, the one before that... until you get to the one you want). Imagine a stack of papers on top of your desk. You can only add more papers to the stack by placing them on top (it'd be unsafe to try to put it in the bottom or in the middle as it can cause it to fall), and you can remove a paper only by taking the top one off first, then the next and so on. This is analagous to a `stack`. A stack is used when you need to make sure elements follow LIFO patterns. Some examples are: JavaScript's call stack, managing function calls in various programming languages, undo/redo functionality some languages offer. There's different ways to implement a stack but the most simple and common is by using an Array with `push` and `pop` methods, where `push` is analogous to putting a paper on top of the pile, and `pop` is like taking a paper off the top. Another way to implement a stack is with a `list` which is a data structure in itself. 

Similar to stacks, there exist queues. They follow the opposite pattern (FIFO); first in, first out. Again, elements can't be added or removed out of order they have to follow the FIFO pattern. Imagine a line of people buying food at a stall. A line is sometimes called a queue hence the name. Who gets food first and leaves? Well it's the person that first got in line. The most recently added person to the line is at the end of the line, hence will be getting food and leaving the queue last. There are various use of queues in JavaScript, some are background tasks and printing/task processing. Similar to stacks, there are different ways to implement one like with a list or Array, but with an Array you instead have a `push()` and `shift()` method. 

Linked lists are a constructed data type not available natively in JavaScript but are very useful. One has to write a linked list themselves. They are data structures that store values in the form of a `list`. Within the list, each value is a `node`, and each node is connected with the following value in the list (or null in the case that the element is the last one in the list) through a `pointer`. There are also doubly linked lists - they are connected to the node following it and preceeding it. The first element of a list is called the `head` and the last is the `tail`. Note that lists do not have indexes. Each value only "knows" the values it's connected to (through pointers). Hence, we can't access values randomly, when you want to access a value you have to traverse the list following `nextNode` (or `previousNode`) until you reach it. The bonus to this downside is that (like stacks and queues) is insertion, deletion and sometimes modification are more efficient than Arrays. The functions that need to be implemented in a list are the constructor (initializing the head, tail and length), `push(value)` - adds a value to the list at the tail end. `pop()` - removes the tail of the list, `shift()` - removes the head of the list, `unshift(value)` - assigns value as head, `get(index)` - finds the element at indice index through iteration, `set(index, value)` - modifies an element at indice index with value value, `insert(index, val)` - puts in a new node at said index, and rearranges the pointers, `remove(index)` - removes the node at the index and rearranges the pointers, `reverse()` - reverses the list and all pointers so head = tail. Doubly linked lists are similar but need to have points to both the nextnode and the previousnode, and it has a little different way of handling head and tail references as it can sometimes be a `loop` or circled list. 

Then there are trees which are data structures that link nodes in a parent/child relationship. Think of a family tree. There is a `root` node, and all the nodes that come off are `children`. Children nodes are actually called children whenever in context to the node above it (the parent). Leaf nodes are nodes with no children and the height of a tree is based on the number of parent/child connections it has. Only connections between child and parent are allowed, no sibling or other connections can occur in a tree, and there can only be 1 root. Some examples of tree usage is : the DOM model, situation analysis in AI, file folders in operating systems and more. There is a special kind of tree called a binary tree - it has the condition that each node has a maximum of two children (left and right). They are useful in conjuction with the binary search trees. 

Next, there is `heaps`. These are another type of tree, and there are two types MaxHeaps and MinHeaps. In MaxHeaps parent nodes are larger than children nodes, while the reverse holds true for MinHeaps. Heaps, specifically binary heaps are used to implement `priority queues` which can perform a well-known algorithm such as Dijkstra's path-finding algorithm. 

There is also `graphs` which are a data structure where nodes can be connected in any way. These are useful for social networks, geolocalization and recommendation systems. They can be undirected or directed (directed graphs have a direction between nodes). They can also be weighted (nodes' connections have different weights).

There are more, complex data structures one can create but these are the most well-known and commonly used. 
