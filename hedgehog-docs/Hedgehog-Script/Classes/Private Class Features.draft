---
sidebar_position: 4
---

import { MathJax, MathJaxContext } from 'better-react-mathjax'


# Private Class Features

If one read the section about public class fields, one may notice that there are no `public` keywords ever used. That is because classes are `public` by default. However, private class members can be made by using a hash (#) prefix.

First, let's point out the most important thing: the difference between private and public. Effectively, public members of a class are available to everyone that can access the class instance. However, private class members are only accessible within that class that instantiated the object.

**Please note that this experiemental syntax isn't implemented in Hedgehog Lab yet. (classPrivateProperties)**

An example:

```js
class ClassWithPrivateField {
    #privateField;
}
class ClassWithPrivateMethod {
    #privateMethod() {
        return 'private method was called';
    }
}
class ClassWithPrivateStaticField {
    static #PRIVATE_STATIC_FIELD; //uppercase for static fields is a common usage
}
class ClassWithPrivateStaticMethod {
    static #privateStaticMethod() {
        return 'private static method was called';
    }
}
```

Note that private fields include both instance and static versions. 

For private instance fields, they are declared with hash names (#nameExample). The # is actually part of the name itself. Private fields are accessible on the class constructor from inside the class declaration itself. They are used for declaration of field names as well as accessing a field's value. Make sure to only refer to hash names in-scope. Also another syntax error is to refer to private fields before they were called, or attempt to remove declared fields with `delete`.

Note: one can use the `in` operator to detect missing private fields or methods. It will return `true` if the private field or method exists, `false` otherwise.

Similarly to public fields, private fields are added at construction time in the base class or at the point where `super()` is invoked in a subclass:

```js
class ClassWithPrivateField {
    #privateField;

    constructor() {
        this.#privateField = 50;
    }
}

class SubClass extends ClassWithPrivateField {
    #subPrivateField;

    constructor() {
        super();
        this.#subPrivateField = 1;
    }
}

new SubClass(); // a new instance of 'SubClass' with the pre-defined #subPrivateField of 1
```

Now private static fields have some similarities to things we've discussed: Like public counterparts, they are only accessible on the class itself or on the `this` context of static methods, but NOT on `this` context of instance methods and especially not accessible by instances but only the class itself. Here is an example of syntax and usage:

```js
class ClassWithPrivateStaticField {
    static #PRIVATE_STATIC_FIELD;

    static publicStaticMethod() {
        ClassWithPrivateStaticField.#PRIVATE_STATIC_FIELD = 50;
        return ClassWithPrivateStaticField.#PRIVATE_STATIC_FIELD;
    }

    publicInstanceMethod() {
        ClassWithPrivateStaticField.#PRIVATE_STATIC_FIELD = 50;
        return ClassWithPrivateStaticField.#PRIVATE_STATIC_FIELD;
    }
}

print(ClassWithPrivateStaticField.publicStaticMethod()); // output is 50
print(new ClassWithPrivateStaticField().publicInstanceMethod()); //output again is 50 but notice that it is called on not the class itself, but rather an instance of it
```

Note a restriction on private static fields: Only the class which defines the private static field can access the field. This can lead to unexpected behavior when using `this`. In the example below, `this` refers to the SubClass class - NOT the BaseClassWithPrivateStaticField class when we try to call SubClass.basePublicStaticMethod(), hence causes a `TypeError`.

```js
class BaseClassWithPrivateStaticField {
    static #PRIVATE_STATIC_FIELD;

    static basePublicStaticMethod() {
        this.#PRIVATE_STATIC_FIELD = 50;
        return this.#PRIVATE_STATIC_FIELD;
    }
}

class SubClass extends BaseClassWithPrivateStaticField { };

let error = null;

try {
    SubClass.basePublicStaticMethod();
} catch(e) {
    error = e;
}

print(error instanceof TypeError); //will output true
print(error); //TypeError: Cannot write private member #PRIVATE_STATIC_FIELD to an object whose class did not declare it
```
Note: there are sections about errors and try-catching.

Now let's discuss private methods - specifically private instance methods. They are methods available on class **instances** not the class itself (that's static), and access is restricted simmilar as private instance fields - only accessible to the class its in. No subclasses or anything that has access to the instance can access the private fields.

To make a private method, similarly to private fields, use a hash name: an example would be - `#privateMethod1() { return 'hello'; }`.

Private instance methods can also be 'getters' or 'setters', although not in generator, async or async generator forms. It is similar to public setters and getters, here is an example:

```js
class ClassWithPrivateAccessor {
    #message;

    get #decoratedMessage() {
        return `hello ${this.#message} goodbye`;
    }

    set #decoratedMessage(msg) {
        this.#message = msg;
    }

    constructor() {
        this.#decoratedMessage = 'world'; //setter
        print(this.#decoratedMessage); //getter
    }
}

new ClassWithPrivateAccessor(); // a class with #message being 'hello world goodbye'
```

Now, private static methods instead of instance methods, are called on the class itself not on instances of the class. Like private static fields, they're only accessible from inside the class declaration:

```js
class ClassWithPrivateStaticMethod {
    static #privateStaticMethod() {
        return 50;
    }
    static publicStaticMethod1() {
        return ClassWithPrivateStaticMethod.#privateStaticMethod();
    }
    static publicStaticMethod2() {
        return this.#privateStaticMethod();
    }
}

print(ClassWithPrivateStaticMethod.publicStaticMethod1() === 50); //true 
print(ClassWithPrivateStaticMethod.publicStaticMethod2() === 50); //true

//note the differences in the return values of method1 vs method2: they both work but are different ways to do it
```

Like private static fields restrictions, they are the same for private static methods and similarly can lead to unexpected behavior when using `this` again. An example would be that a TypeError would be thrown if a subclass derived from a base class calls a public static method and the public static method uses `this`. However if it uses the class itself to access the information or method it will work.

Overall, like public class, private class features are complex and lengthy. The most important thing is understanding the difference between private and public, and static and instance fields and methods.