import { MathJax, MathJaxContext } from 'better-react-mathjax'


# The Set Object

The `Set` object is a built-in object used for storing unique values of any type! It can be primitive values like `string` or `boolean` or even object references, and they can all be different. It's best to think of it as a set in mathematics, which is what it's based off: a set in mathematics is a collection of different things, the set contains elements/members which can be mathematical objects of any kind: numbers, symbols, points in space, lines, variable or even other sets. They are effectively containers for general values, of any type.

One important note (that differs from mathematical sets) is that a `set` has **unique** values meaning no value can be duplicate. 

One can iterate or go through a set's elements in 'insertion order', which corresponds to the order in which element was inserted into the set by the `add()` method successfully. Also, the specification of a set requires them to be implemented such that on average, they provide access times (to elements) that are sublinear on the number of elements. Hence, sets can be represented internally as a hash table with O(1) lookup, a search tree with O(log(N)) lookup or any other data structure, as long as the complexity is better than O(N) (linear time).

There is a `has` method that checks if a value is in a `Set` object. It is a relatively fast method. Faster than Array.prototype.includes method, when the `Array.length === Set.size`.

The constructor of `Set` creates a new `Set` object by calling `Set()`.

One static property is `get Set[@@species]`. The constructor function is the one that's used to creat derived objects. (Read the name like this: `Set[Symbol.species] or Set[@@species]` is an accessor property returning the `Set` constructor, and we 'get' it.)

An instance property is: `Set.prototype.size` which returns the number of values in the `Set` object.

The instance methods are: 

`Set.prototype.add()` - Inserts a new element with a specified value in to a `Set` object, **if** there isn't one with the same value already.

`Set.prototype.clear()` - Remove all elements from the `Set` object.

`Set.prototype.delete()` - removes an element associated to the `value` and returns a `boolean` asserting whether the element was successfully removed or not. Afterwards, `Set.prototype.has(value)` will return `false`.

`Set.prototype.has()` - Returns a boolean asserting that an element is present with the given value in the `Set` object or not. 

`Set.prototype[@@iterator]()` - Returns a new iterator object that yields the `values` for each element in the `Set` object in **insertion order**.

`Set.prototype.values()` - Same as `Set.prototype[@@iterator]()`.

`Set.prototype.keys()` - an alias, or different name for `Set.prototype.values()`.

`Set.prototype.entries()` - Returns a new iterator object which contains an array of `[value, value]` for each element in the `Set` object, in insertion order. This is quite similar to the `Map` object, in that each entry's key is the same as its value for a `Set`.

`Set.prototype.forEach()` - Calls `callbackFn` once for each value present in the `Set` object, in insertion order. If a `thisArg` parameter is provided, it will be uses as the `this` value for each invocation of `callbackFn`. Another way to think about it is by thinking about `Array`'s `forEach()` method.

Some examples of using the `Set` object:

```js
const set1 = new Set();

set1.add(1);
set1.add(5);
set1.add(5);
set1.add('text');
const o = {a: 1, b: 2};
set1.add(o);
//the set1 is currently: [1,5,'text', {"a": 1, "b": 2}], this is insertion order
set1.add({a:1, b:2}); //this is okay and is not a duplicate as o is referencing a different object
set1.has(1); //true
set1.has(3); //false - 3 has never been added
set1.has(5); //true
set1.has(Math.sqrt(25)); //true! Math.sqrt(25) is evaluated to the primitive int 5, and the primitive int of value 5 has been added
set1.has('Text'.toLowerCase()); // true as this evaluates to the primitive string 'text' which is in here.
set1.has(o); //true, it has a reference to the object o

set1.size; //5

set1.delete(5); //removes 5 from the set
set.has(5); //false, 5 was just removed

set1.size; //4

set1.add(5); //set object is now [1,'text', {"a": 1, "b": 2}, {"a":1, "b":2}, 5] - 5 is now at the end due to insertion order

//Now for set iteration:

//iterate over items in the set, and prints the elements in insertion order

for (const element of set1) {
    print(element);
}
// will output : 1, "text", {"a":1, "b":2}, {"a":1, "b":2}, 5

for (const element of set1.keys()) {
    print(element);
}
//exact same as above

for (const element of set1.values()) {
    print(element);
}
//same exact again

for (const [key, value] of set1.entries()) {
    print(key);
}
//same again since key and values are the same

//now lets convert the set to an array with Array.from
const arr1 = Array.from(set1); // Array is [1, "text", {"a":1, "b":2}, {"a":1, "b":2}, 5]

//the following will work if run in an HTML doc
set1.add(document.body);
set1.has(document.querySelector('body')); //true

//converting between Set and Array:
const set2 = new Set([1,2,3,4]);
print(set2.size); // 4
print([...set2]); // [1,2,3,4]

//intersections can be simulated:

const intersec = new Set([...set1].filter((x) => set2.has(x)));

//difference can be simulated too:

const diff = new Set([...set1].filter((x) => !set2.has(x)));

//iterate set entries with forEach():
set2.forEach( (value) => {
    print(value);
});

// 1 2 3 4 
```

Phew that was alot! Now let's implement basic set operations:

```js
function isSuperset(set, subset) {
    for(const elem of subset) {
        if (!set.has(elem)) {
            return false;
        }
    }
    return true;
}
function union(setA,setB) {
    const _union = new Set(setA);
    for (const elem of setB) {
        _union.add(elem);
    }
    return _union;
}
function intersection(setA, setB) {
    const _intersection = new Set();
    for (const elem of setB) {
        if (setA.has(elem)) {
            _intersection.add(elem)
        }
    }
    return _intersection;
}
function symmetricDifference(setA,setB) {
    const _difference = new Set(setA);
    for (const elem of setB) {
        if (_difference.has(elem)) {
            _difference.delete(elem);
        }
        else {
            _difference.add(elem);
        }
    }
    return _difference;
}
function difference(setA,setB) {
    const _difference = new Set(setA);
    for (const elem of setB) {
        _difference.delete(elem);
    }
    return _difference;
}

//examples:

const setA = new Set([1,2,3,4]);
const setB = new Set([2,3]);
const setC = new Set([3,4,5,6]);

isSuperset(setA,setB); //true
union(setA, setC); //returns  Set {1,2,3,4,5,6}
intersection(setA, setC); //returns Set {3, 4}
symmetricDifference(setA, setC); //returns Set {1, 2, 5, 6}
difference(setA, setC); //returns Set {1, 2}
```

A good technique of using sets is to remove duplicate elements from an array:

```js
const nums = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,50,3,4,5];
print([...new Set(nums)]); //output is [2,3,4,5,6,7,50];
```

Lastly, let's go over a quick example of Set's relation to Strings:

```js
const text = 'China';
const set1 = new Set(text); // set of size 5: {'C', 'h', 'i', 'n', 'a'}
//note that it's case sensitive. If the text was 'china' the first entry would not be 'C' but rather 'c'.
//thus sets are useful for decomposing strings
```

Overall Sets are a unique tool different than Arrays. The primary difference is that Sets don't hold duplicate values, and you can't access or add according to indice, there is just insertion order. However, Sets are faster than Arrays for a variety of techniques. Sets can also be used for things such as decomposing Strings or removing duplicate values in an Array. One last note is that Sets are interesting and can be powerful, however, they aren't used that frequently.

